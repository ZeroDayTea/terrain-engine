#version 430 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

const int CHUNK_WIDTH = 64;
const int CHUNK_HEIGHT = 64;
const int CHUNK_DEPTH = 64;

layout(std430, binding = 0) readonly buffer DensityBuffer { float densities[]; };
layout(std430, binding = 1) readonly buffer TriangleTable { int triTable[]; };
layout(std430, binding = 2) readonly buffer EdgeTable { int edgeTable[]; };
layout(std430, binding = 3) writeonly buffer VertexBuffer { uvec2 vertices[]; }; // stores packed vertex data
layout(std430, binding = 5) readonly buffer OffsetBuffer { uint offsets[]; };

uniform float isolevel;

const uint POSITION_BITS = 10u;
const float POS_Q_MAX = float((1u<<POSITION_BITS)-1u);
const float INV_STEP = POS_Q_MAX / 64.0;

// packing chunk-local position data to 10 bits per axis
uint pack_position(vec3 localPos) {
    vec3 p = clamp(localPos, vec3(0.0), vec3(64.0));
    vec3 q = p * INV_STEP;
    uvec3 iu = uvec3(floor(q));
    return (iu.x & 1023u) | ((iu.y & 1023u) << 10) | ((iu.z & 1023u) << 20);
}

uvec2 sign_not_zero(vec2 v) {
    return uvec2(v.x < 0.0 ? 0u : 1u, v.y < 0.0 ? 0u : 1u);
}

// packing normal data to oct-encoded
uint pack_oct(vec3 n) {
    n = normalize(n);
    vec3 a = abs(n);
    vec2 p = (n.z >= 0.0) ? (n.xy / (a.x + a.y + a.z))
                          : ((1.0 - a.yx / (a.x + a.y + a.z)) * (vec2(n.x >= 0.0 ? 1.0 : -1.0, n.y >= 0.0 ? 1.0 : -1.0)));
    p = p * 0.5 + 0.5;

    const uint NB = 11u;
    const float NQ = float((1u << NB) - 1u);
    uint u = uint(round(clamp(p.x, 0.0, 1.0) * NQ));
    uint v = uint(round(clamp(p.y, 0.0, 1.0) * NQ));
    return u | (v << NB);
}

uint densityIndex(ivec3 p) {
    return uint(p.z) * uint(CHUNK_WIDTH + 1) * uint(CHUNK_HEIGHT + 1)
        + uint(p.y) * uint(CHUNK_WIDTH + 1)
        + uint(p.x);
}

uint voxelIndex(ivec3 p) {
    return uint(p.z) * uint(CHUNK_WIDTH) * uint(CHUNK_HEIGHT)
        + uint(p.y) * uint(CHUNK_WIDTH)
        + uint(p.x);
}

vec3 interpolate_vertex(vec3 p1, vec3 p2, float v1, float v2) {
    if (abs(v1 - v2) < 0.00001) return p1;
    float t = (isolevel - v1) / (v2 - v1);
    return mix(p1, p2, clamp(t, 0.0, 1.0));
}

vec3 gradientNorm(ivec3 pos) {
    ivec3 maxp = ivec3(CHUNK_WIDTH, CHUNK_HEIGHT, CHUNK_DEPTH);
    int x0 = clamp(pos.x - 1, 0, CHUNK_WIDTH);
    int x1 = clamp(pos.x + 1, 0, CHUNK_WIDTH);
    int y0 = clamp(pos.y - 1, 0, CHUNK_HEIGHT);
    int y1 = clamp(pos.y + 1, 0, CHUNK_HEIGHT);
    int z0 = clamp(pos.z - 1, 0, CHUNK_DEPTH);
    int z1 = clamp(pos.z + 1, 0, CHUNK_DEPTH);

    float dx0 = densities[densityIndex(ivec3(x0,pos.y,pos.z))];
    float dx1 = densities[densityIndex(ivec3(x1,pos.y,pos.z))];
    float dy0 = densities[densityIndex(ivec3(pos.x,y0,pos.z))];
    float dy1 = densities[densityIndex(ivec3(pos.x,y1,pos.z))];
    float dz0 = densities[densityIndex(ivec3(pos.x,pos.y,z0))];
    float dz1 = densities[densityIndex(ivec3(pos.x,pos.y,z1))];

    vec3 g = vec3(dx1 - dx0, dy1 - dy0, dz1 - dz0);
    return normalize(-g);
}

void main() {
    ivec3 id = ivec3(gl_GlobalInvocationID);
    if (id.x >= CHUNK_WIDTH || id.y >= CHUNK_HEIGHT || id.z >= CHUNK_DEPTH) {
        return;
    }

    vec3 cornerOffsets[8] = vec3[8](
        vec3(0,0,0), vec3(1,0,0), vec3(1,0,1), vec3(0,0,1),
        vec3(0,1,0), vec3(1,1,0), vec3(1,1,1), vec3(0,1,1)
    );

    float cv[8];
    for (int i = 0; i < 8; ++i) {
        cv[i] = densities[densityIndex(id + ivec3(cornerOffsets[i]))];
    }

    int cubeIndex = 0;
    // for (int i = 0; i < 8; ++i) {
    //     if (cv[i] > isolevel) cubeIndex |= pow(2, i);
    // }
    if (cv[0] > isolevel) cubeIndex |= 1;
    if (cv[1] > isolevel) cubeIndex |= 2;
    if (cv[2] > isolevel) cubeIndex |= 4;
    if (cv[3] > isolevel) cubeIndex |= 8;
    if (cv[4] > isolevel) cubeIndex |= 16;
    if (cv[5] > isolevel) cubeIndex |= 32;
    if (cv[6] > isolevel) cubeIndex |= 64;
    if (cv[7] > isolevel) cubeIndex |= 128;

    int mask = edgeTable[cubeIndex];
    if (mask == 0) return;

    int cornersFromEdge[12][2] = int[12][2](
        int[2](0,1), int[2](1,2), int[2](2,3), int[2](3,0),
        int[2](4,5), int[2](5,6), int[2](6,7), int[2](7,4),
        int[2](0,4), int[2](1,5), int[2](2,6), int[2](3,7)
    );

    int base = cubeIndex * 16;

    // voxel's start vertex offset from the first pass
    uint baseOffset = offsets[voxelIndex(id)];

    uint triIdx = 0u;
    for (int i = 0; triTable[base + i] != -1; i += 3) {
        int e0 = triTable[base + i + 0];
        int e1 = triTable[base + i + 1];
        int e2 = triTable[base + i + 2];

        int a0 = cornersFromEdge[e0][0];
        int b0 = cornersFromEdge[e0][1];
        int a1 = cornersFromEdge[e1][0];
        int b1 = cornersFromEdge[e1][1];
        int a2 = cornersFromEdge[e2][0];
        int b2 = cornersFromEdge[e2][1];

        vec3 p0 = vec3(id) + cornerOffsets[a0];
        vec3 p1 = vec3(id) + cornerOffsets[b0];
        vec3 p2 = vec3(id) + cornerOffsets[a1];
        vec3 p3 = vec3(id) + cornerOffsets[b1];
        vec3 p4 = vec3(id) + cornerOffsets[a2];
        vec3 p5 = vec3(id) + cornerOffsets[b2];

        vec3 v0 = interpolate_vertex(p0, p1, cv[a0], cv[b0]);
        vec3 v1 = interpolate_vertex(p2, p3, cv[a1], cv[b1]);
        vec3 v2 = interpolate_vertex(p4, p5, cv[a2], cv[b2]);

        // basic vertex normal calculation with interpolation
        vec3 n1 = gradientNorm(id + ivec3(cornerOffsets[a0]));
        vec3 n2 = gradientNorm(id + ivec3(cornerOffsets[b0]));
        float t = clamp((isolevel - cv[a0]) / max(0.00001, (cv[b0] - cv[a0])), 0.0, 1.0);
        vec3 N = normalize(mix(n1, n2, t));

        // packed position and normal data (two 32 bit values)
        uint P0 = pack_position(v0);
        uint P1 = pack_position(v1);
        uint P2 = pack_position(v2);
        uint N0 = pack_oct(N);

        uint w = baseOffset + triIdx * 3u;
        vertices[w + 0] = uvec2(P0, N0);
        vertices[w + 1] = uvec2(P1, N0);
        vertices[w + 2] = uvec2(P2, N0);

        triIdx++;
    }
}
