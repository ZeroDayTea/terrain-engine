#version 430 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

const int CHUNK_WIDTH = 64;
const int CHUNK_HEIGHT = 64;
const int CHUNK_DEPTH = 64;

struct Vertex {vec4 pos; vec4 norm; };

layout(std430, binding = 0) readonly buffer DensityBuffer { float densities[]; };
layout(std430, binding = 1) readonly buffer TriangleTable { int triTable[]; };
layout(std430, binding = 2) readonly buffer EdgeTable { int edgeTable[]; };
layout(std430, binding = 3) writeonly buffer VertexBuffer { Vertex vertices[]; };
layout(std430, binding = 5) readonly buffer OffsetBuffer { uint offsets[]; };

uniform float isolevel;

uint densityIndex(ivec3 p) {
    return uint(p.z) * uint(CHUNK_WIDTH + 1) * uint(CHUNK_HEIGHT + 1)
        + uint(p.y) * uint(CHUNK_WIDTH + 1)
        + uint(p.x);
}

uint voxelIndex(ivec3 p) {
    return uint(p.z) * uint(CHUNK_WIDTH) * uint(CHUNK_HEIGHT)
        + uint(p.y) * uint(CHUNK_WIDTH)
        + uint(p.x);
}

vec3 interpolate_vertex(vec3 p1, vec3 p2, float v1, float v2) {
    if (abs(v1 - v2) < 0.00001) return p1;
    float t = (isolevel - v1) / (v2 - v1);
    return mix(p1, p2, t);
}

vec3 gradientNorm(ivec3 pos) {
    ivec3 maxp = ivec3(CHUNK_WIDTH, CHUNK_HEIGHT, CHUNK_DEPTH);
    int x0 = clamp(pos.x - 1, 0, CHUNK_WIDTH);
    int x1 = clamp(pos.x + 1, 0, CHUNK_WIDTH);
    int y0 = clamp(pos.y - 1, 0, CHUNK_HEIGHT);
    int y1 = clamp(pos.y + 1, 0, CHUNK_HEIGHT);
    int z0 = clamp(pos.z - 1, 0, CHUNK_DEPTH);
    int z1 = clamp(pos.z + 1, 0, CHUNK_DEPTH);

    float dx0 = densities[densityIndex(ivec3(x0,pos.y,pos.z))];
    float dx1 = densities[densityIndex(ivec3(x1,pos.y,pos.z))];
    float dy0 = densities[densityIndex(ivec3(pos.x,y0,pos.z))];
    float dy1 = densities[densityIndex(ivec3(pos.x,y1,pos.z))];
    float dz0 = densities[densityIndex(ivec3(pos.x,pos.y,z0))];
    float dz1 = densities[densityIndex(ivec3(pos.x,pos.y,z1))];

    vec3 g = vec3(dx1 - dx0, dy1 - dy0, dz1 - dz0);
    return normalize(-g);
}

void main() {
    ivec3 id = ivec3(gl_GlobalInvocationID);
    if (id.x >= CHUNK_WIDTH || id.y >= CHUNK_HEIGHT || id.z >= CHUNK_DEPTH) {
        return;
    }

    vec3 cornerOffsets[8] = vec3[8](
        vec3(0,0,0), vec3(1,0,0), vec3(1,0,1), vec3(0,0,1),
        vec3(0,1,0), vec3(1,1,0), vec3(1,1,1), vec3(0,1,1)
    );

    float cv[8];
    for (int i = 0; i < 8; ++i) {
        cv[i] = densities[densityIndex(id + ivec3(cornerOffsets[i]))];
    }

    int cubeIndex = 0;
    // for (int i = 0; i < 8; ++i) {
    //     if (cv[i] > isolevel) cubeIndex |= pow(2, i);
    // }
    if (cv[0] > isolevel) cubeIndex |= 1;
    if (cv[1] > isolevel) cubeIndex |= 2;
    if (cv[2] > isolevel) cubeIndex |= 4;
    if (cv[3] > isolevel) cubeIndex |= 8;
    if (cv[4] > isolevel) cubeIndex |= 16;
    if (cv[5] > isolevel) cubeIndex |= 32;
    if (cv[6] > isolevel) cubeIndex |= 64;
    if (cv[7] > isolevel) cubeIndex |= 128;

    int mask = edgeTable[cubeIndex];
    if (mask == 0) return;

    int cornersFromEdge[12][2] = int[12][2](
        int[2](0,1), int[2](1,2), int[2](2,3), int[2](3,0),
        int[2](4,5), int[2](5,6), int[2](6,7), int[2](7,4),
        int[2](0,4), int[2](1,5), int[2](2,6), int[2](3,7)
    );

    int base = cubeIndex * 16;

    // voxel's start vertex offset from the first pass
    uint baseOffset = offsets[voxelIndex(id)];

    uint triIdx = 0u;
    for (int i = 0; triTable[base + i] != -1; i += 3) {
        int e0 = triTable[base + i + 0];
        int e1 = triTable[base + i + 1];
        int e2 = triTable[base + i + 2];

        int a0 = cornersFromEdge[e0][0];
        int b0 = cornersFromEdge[e0][1];
        int a1 = cornersFromEdge[e1][0];
        int b1 = cornersFromEdge[e1][1];
        int a2 = cornersFromEdge[e2][0];
        int b2 = cornersFromEdge[e2][1];

        vec3 p0 = vec3(id) + cornerOffsets[a0];
        vec3 p1 = vec3(id) + cornerOffsets[b0];
        vec3 p2 = vec3(id) + cornerOffsets[a1];
        vec3 p3 = vec3(id) + cornerOffsets[b1];
        vec3 p4 = vec3(id) + cornerOffsets[a2];
        vec3 p5 = vec3(id) + cornerOffsets[b2];

        vec3 v0 = interpolate_vertex(p0, p1, cv[a0], cv[b0]);
        vec3 v1 = interpolate_vertex(p2, p3, cv[a1], cv[b1]);
        vec3 v2 = interpolate_vertex(p4, p5, cv[a2], cv[b2]);

        // basic vertex normal calculation
        vec3 n1 = gradientNorm(id + ivec3(cornerOffsets[a0]));
        vec3 n2 = gradientNorm(id + ivec3(cornerOffsets[b0]));
        float t = (isolevel - cv[a0]) / max(0.00001, (cv[b0] - cv[a0]));
        vec3 N = normalize(mix(n1, n2, clamp(t, 0.0, 1.0)));

        uint w = baseOffset + triIdx * 3u;
        vertices[w + 0] = Vertex(vec4(v0, 1.0), vec4(N, 0.0));
        vertices[w + 1] = Vertex(vec4(v1, 1.0), vec4(N, 0.0));
        vertices[w + 2] = Vertex(vec4(v2, 1.0), vec4(N, 0.0));

        triIdx++;
    }
}
